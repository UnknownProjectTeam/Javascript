#4. 함수와 프로토타입 체이닝

##4.1 함수 정의

- javascript에서 함수를 생성하는 방법은 3가지가 있음
- 함수 선언문, 함수 표현식, Function()생성자 사용

###4.1.1 함수 리터럴

- javascript에서 함수 정의을 위해 사용하는 포멧으로 리턴이 있는 function 형태 
- JAVA의 method 와 흡사하지만 매개변수의 type이 없음
- 함수명은 생략 가능함.

```javascript
function add(x, y){
	return x+y;
}
```

>  리터럴
>
>  * 코드상에서 데이터를 표현하는 방식
>
>  ```javascript
>   var aaa = 2; //숫자
>   var bbb = "2"; //문자
>   var bbb = '2'; //얘도 문자
>   var ccc = true; //얘는 불린
>   var ddd = [1, 2, 3, 4]; //얘는 배열
>   var eee = { p1 : 2, p2 : ‘2’ }; //얘는 객체
>   var fff = null; //null
>   var ggg = undefined; //undefined
>   var hhh = function(){ alert('ㅋㅋㅋ'); } //얘는 함수!! 
>  ```
>

###4.1.2 함수 선언문

- 함수 생성방식의 1가지로 반드시 함수명이 정의되어 있어야 함.
- 일반적으로 닫힘 중괄호( } ) 뒤에 세미콜론( ; )을 붇이지 않음.
- Q) 세미콜론을 붇이면 영향이 있나???

```javascript
function add(x, y){
	return x+y;
}
console.log(add(3,4));	//출력값 = 7  
```

###4.1.3 함수 표현식

- 함수 생성방식의 1가지로 함수 생성하여 변수에 할당하여 사용하는 방식.
- 함수명은 생략 가능함. 
- 닫힘 중괄호( } ) 뒤에 세미콜론( ; )을 붇임. -> 세미콜론을 안붇일 경우 자바스크립트 엔진에서 코드가 안끝났다 판단을 하고 이후 코드까지 읽어버려 원하는 결과를 얻지 못함. 그렇기에 함수 표현식에서는 세미콜론 사용을 강력하게 권고함.

```javascript
var add = function (x, y){
	return x+y;   
};
var plus = add;
console.log(add(3,4));	// 출력값 7
console.log(plus(5,6));	//출력값 11
```

- 함수명을 생략한 함수 : 익명함수
- 함수명을 명시한 함수 : 기명함수
- 함수표현식에서 기명함수 사용시 유의할 점
  함수표현식에 사용된 함수이름은 외부코드에서 접근이 불가능함. 
  따라서 보편적으로 익명함수로 작성하거나 함수명을 변수와 동일하게 작성함.
  실제 위 코드도 자바스크립트 엔진이 내부적으로 아래와 같은 코드로 변경되기에 add(3,4)가 가능한 것임….

```javascript
var add = function sum(x, y){
	return x+y;
};

console.log(add(3,4));	// 출력값 7
console.log(sum(5,6));	// sum is not defined
```

###4.1.4 Function() 생성자

- 잘 사용하지 않음.. 알고만 있자...

```javascript
var add = new Function('x', 'y', 'return x+y');
console.log(add(3,4));
```


###4.1.5 함수 호이스팅(Function Hoisting)

- 함수 선언문 형태의 함수의 유효범위가 코드의 맨 처음부터이기 때문에 함수를 정의하기 전에 사용이 가능함. 
  - 코드 구조가 엉성해 질 수 있으므로 선언문을 사용하려면 함수 선언 후 사용하거나, 함수 표현식 사용을 권장함.
- 함수 호이스팅의 발생원인은 자바스크립트의 변수생성과 초기화의 작업이 분리 진행되기 때문임 
  - 5장에서 다룰 예정.

##4.2 함수 객체

###4.2.1 자바스크립트에서는 함수도 객체다

- 함수 코드 실행 뿐이 아닌, 일반객체 처럼 프로퍼티들을 가질 수 있음.
- 코드는 [[Code]] 내부 프로퍼티에 자동으로 적재됨
- 특정 프로퍼티를 추가 가능함.

###4.2.2 자바스크립트에서 함수는 값으로 취급됨

- 아래와 같은 함수의 가능 동작으로 인해 함수를 일급 객체 라고 함

  >A. 리터럴에 의해 생성
  >
  >B. 변수나 배열의 요소 객체의 프로퍼티등에 할당 가능
  >
  >C. 함수의 인자로 전달 가능
  >
  >D. 함수의 리턴값으로 리턴 가능
  >
  >E. 동적으로 프로퍼티 생성 및 할당 가능

####4.2.2.1 변수나 프로퍼티의 값으로 할당

####4.2.2.2 함수 인자로 전달

####4.2.2.3 리턴값으로 활용

###4.2.3 함수 객체의 기본 프로퍼티

- 기본 프로퍼티 : length, prototype
- ECMA 표준이 아닌 프로퍼티 : name, caller, arguments, [[Prototype]]
- name : 함수명, 익명함수인 경우 빈문자열
- arguments : 함수 호출 시 전달된 인자
- [[Prototype]] : 모든 객체/함수가 가지는 프로토타입 객체

####4.2.3.1 length

- 모든 함수가 가져야 하는 표준 프로퍼티
- 함수가 정상 실행될 때 기대되는 인자 개수

####4.2.3.2 prototype

- 모든 함수가 가지는 객체 -> 내부 프로퍼티인 [[Prototype]]과 틀림 
- 함수가 생성되는 시점에 만들어지며 constructor 프로퍼티만 가지고 있음
  -->  JAVA의 기본 생성자 개념으로 보이는데…맞나…?

##4.3 함수의 다양한 형태

###4.3.1 콜백 함수

- 이벤트 발생 및 특정 시점에 시스템에서 호출되는 함수 
  ex> window.onload 

###4.3.2 즉시실행 함수

- 함수 정의와 동시에 실행되는 함수
- 다수의 라이브러리에서 초기화 코드에 주로 사용됨

```javascript
(function(name){
	console.log('name -> '+name);
})('foo');
```

###4.3.3 내부함수

- function 안의 function
- 내부함수에서는 자신을 둘러싼 부모함수로 접근 가능함. -> 스코프 체이닝
- 일반적으로 자신이 정의돈 부모함수 내에서만 호출이 가능함.
- 함수 스코프 외부에서 내부함수 호출을 위해서는 부모함수에서 반환(return)해주면 됨.
- 실행이 끝난 함수의 스코프 변수를 참조하는 것을 클로저라 함.

###4.3.4 함수를 리턴하는 함수
- 함수 호출에 대한 리턴으로 함수를 받아 처리가능. -> 유연성...
- Q) 이렇게 헤깔리게 해야 할까? 어따 써??

## 4.4 함수 호출과 this

### 4.4.1 arguments 객체

- 함수 형식에 맞지않는 인자 갯수를 넘겨도 오류가 발생하지 않음.
- 함수의 인자보다 적게 넘길경우 undefind값이 할당됨.
- 함수의 인자보다 많게 넘길경우 초과된 인수는 무시됨.
- 이를 가능하게 하는 객체가 arguments객체임.
- 유사배열객체로 배열처럼 동작하지만, 배열 메서드 사용시 오류발생.
- 매개변수 갯수가 정해지지 않은 함수 구현 및 전달된 인자의 갯수에 따라 다른 처리를 해줘야 하는 함수 개발에 유용함.

### 4.4.2 호출 패턴과 this 바인딩

- this 바인딩 : 자바스크립트의 핵심개념이며 함수호출패턴에 따라 다른객체를 참조하기 때문에 헤깔림

#### 4.4.2.1 객체의 메서드 호출할 때 this 바인딩

- 메서드 내부 코드에서 사용된 this는 해당 메서드를 호출한 객체로 바인딩 됨

```javascript
//sayName 객체의 프로퍼티이면서 함수이면 메서드라 지칭한다.
var myObject = {
	name : ‘foo’,
	sayName : function(){
		console.log(this.name);
	}
};

//otherObject 생성 - name 프로퍼티 가지고 있음
var otherObject = {
	name : ‘bar’
};
 
//sayName 메서드를 otherObject에서도 사용 가능하도록 함. 
otherObject.sayName = myObject.sayName;

myObject.sayName(); //myObject의 name 프로퍼티(foo) 바인딩됨
otherObject.sayName(); //otherObject의 name 프로퍼티(bar) 바인딩됨
```

#### 4.4.2.2 함수를 호출할 때 this 바인딩

- 함수 호출 시 해당 함수 내부 코드에서 사용된 this는 전역객체에 바인딩 된다.
- 브라우저에서 자바스크립트를 실행하는경우 전역객체(window객체)에 바인딩 된다.
- 함수 내 함수 호출 시에도 동일하여 메서드 도 함수이기 때문에 의도치않게 전역변수를 바인딩 할 수 있으므로 메서드 내부에서 다른 변수(that)에 저장하여 처리하여야 함.

#### 4.4.2.3 생성자 함수를 호출할 때 this 바인딩

	>빈 객체 생성 및 this 바인딩
	>
	>this를 통한 프로퍼티 생성
	>
	>생성된 객체 리턴

- 객체 리터럴 방식과 생성자 함수 방식의 차이점
  - 객체 리터럴 방식 : 같은 형태의 객체를 재생성하지 못함
  - 생성자 함수 방식 :  new 를 이용해 같은 형태의 객체를 재생성 가능
- 생성자 함수를 new 붙이지 않거나 일반 함수를 new 붙이면 this 바인딩 방식이 틀려 오류가 발생할 수 있음.
  - 일반함수 : 전역변수(window)에 바인딩
  - 생성자 함수 : 신규 생성 빈(empty) 객체에 바인딩
- 위 오류를 보정하기 위해 사용자가 함수 작성자의 의도와 다르게 함수 호출을 수행해도 문제가 발생하지 않도록 특정 패턴을 적용하여 함수를 구성함.


```javascript
//사용자가 new를 사용하여 호출하든 안하든 똑똑하게 처리해주는 패턴
// this가 바인딩 할 객체가 없을 경우 생성자 함수 호출
function A(arg){
	if ( !(this instanceof A))
		return new A(arg);
	this.value = arg ? arg : 0;
}
```

#### 4.4.2.4 call과 apply 메서드를 이용한 명시적 this 바인딩

- 특정 객체에 명시적으로 this 바인딩을 할 수 있음

---

date : 20161106

### 4.4.3 함수 리턴

- 자바스크립트 함수(function)은 명시적으로 return 하지 않아도 항상 리턴값을 반환함.

#### 4.4.3.1 규칙1) 일반 함수나 메서드는 리턴값을 지정하지 않을 경우 undefined 값 리턴

#### 4.4.3.2 규칙2) 생성자 함수에서 리턴값을 지정하지 않을 경우  생성된 객체 리턴

- 명시적으로 객체를 return을 하면 명시한 객체가 리턴됨.
- 명시적으로 객체가 아닌 boolean, 숫자, 문자열을 return 하면 this 바인딩 된 객체가 리턴됨.

## 4.5 프로토타입 체이닝


### 4.5.1 프로토타입의 두가지 의미


- 자바스크립트는 프로토타입 객체지향 프로그래밍을 지원함
- [[Prototype]] 프로퍼티 : 모든 객체의 숨겨진 프로퍼티로 자신의 부모 프로토타입 객체를 가리키는 암묵적 프로토타입 링크
- prototype 프로퍼티 : 프로토타입 객체를 가리키는 프로퍼티
- prototype 프로퍼티는 함수의 입장에서 링크 된 프로토타입 객체를 가리키고, [[Prototype]]링크는 객체의 입장에서 자신의 부모 객체인 프로토타입 객체를 숨겨진 링크로 가리킨다.


### 4.5.2 객체 리터럴 방식으로 생성된 객체의 프로토타입 체이닝


- 프로토타입 체이닝 : 객체가 자기자신의 프로퍼티 및 부모 프로토타입 객체의 프로퍼티도 접근이 가능하도록 해줌.
- 특정 객체의 프로퍼티/메서드 접근 요청 시, 해당 객체에 접근하려는 프로퍼티/메서드가 없을 경우 [[Prototype]]링크를 따라 부모 프로토타입 객체의 프로퍼티를 찾아 수행한다.


### 4.5.3 생성자 함수로 생성된 객체의 프로토타입 체이닝 


- 4.5.2와 비슷..


### 4.5.4 프로토타입 체이닝의 종점


- Object.prototype
- 표준 메서드들이 모두 있기에 오류 안남.


### 4.5.5 기본 데이터 타입 확장


- 기본 내장 프로토타입(Object, String등) 객체에 사용자 정의 메서드를 추가하여 공통적으로 사용할 수 있음.


### 4.5.6 프로토타입도 자바스크립트 객체이다


- 프로토타입 객체도 동적으로 프로퍼티 추가/삭제가 가능하며, 실시간으로 프로토타입 체이닝에 반영된다.


### 4.5.7 프로토타입 메서드와 this 바인딩


- 프로토타입 메서드에서 this바인딩을 하면 메서드를 호출한 객체에 바인딩된다.
  (4.4.2.1과 동일)


### 4.5.8 디폴트 타입은 다른객체로 변경이 가능하다


### 4.5.9 객체의 프로퍼티 읽기나 메서드를 실행할 때만 프로토타입 체이닝이 동작한다


- 자바스크립트는 객체에 없는 프로퍼티에 값을 쓰려고 할 경우 동적으로 객체에 프로퍼티를 추가함. 
