# 1. 자바스크립트 기본 개요
## 1.1 소개
### 웹 브라우저에서 동작하는 스크립트 언어, jQuery의 등장으로 보다 쉽게 DOM을 핸들링하게 되면서 많은 발전을 이룸
## 1.2 자바스크립트 활용 범위
### 브라우저 기반의 자바스크립트 라이브러리뿐만 아니라, Node.js와 같은 서버 기반의 자바스크립트 라이브러리 등장으로 웹 서버와 클라이언트인 웹 페이지 개발을 동시에 할 수 있게 되었다.
### 1.2.1 웹개발
- 크롬, 파이어폭스 등 브라우저의 발달로 자바스크립트 엔진 성능 향상

### 1.2.2 서버 개발
- Node.js의 출현으로 자바스크립트를 활용한 서버 개발이 활발히 이루어지고 있음

### 1.2.3 애플리케이션 개발
- 크롬OS, HP의 웹OS 등 웹 기발 플랫폼에서 구동되는 애플리케이션이 개발되고 있음
- 폰갭과 같은 크로스 플랫폼 개발 도구를 이용하여 DOM 요소를 핸들링하여 랜더링하는 것부터 디바이스의 동작에 대한 제어도 가능

## 1.3 자바스크립트의 핵심 개념
### 1.3.1 객체
- 기본 데이터 타입인 boolean, number, string, 특별한 값인 null, undefined 외 자바스크립트의 거의 모든 것은 객체이다.
- null, undefined 외 기본 데이터 타입도 객체로 다룰 수 있다.

### 1.3.2 함수
- 함수도 객체로 취급(일급 객체)

### 1.3.3 프로토타입
- 모든 객체는 숨겨진 링크인 프로토타입을 가진다. 링크는 해당 객체를 생성한 생성자의 프로토타입 객체를 가리킨다.

### 1.3.4 실행 컨텍스트와 클로저
- 자바스크립트는 자신만의 독특한 과정으로 실행 컨텍스트를 만들고 그 안에서 실행이 이루어진다.
- 실행 컨텍스트는 Scope을 갖고, 이 과정에서 클로저를 구현할 수 있다.

## 1.4 자바스크립트와 객체지향 프로그래밍
### 프로토타입 체인과 클로저로 객체지향 프로그래밍에서 제시하는 상속, 캡슐화, 정보 은닉 등의 개념을 소화할 수 있다.
## 1.5 자바스크립트와 함수형 프로그래밍
### 함수의 일급 개체로서의 특성과 클로저를 이용하면 가능
## 1.6 자바스크립트의 단점
### 디버깅이 어려움. 전역 객체의 관리가 어려움

# 2. 자바스크립트 개발 환경
## SKIP..

# 3. 자바스크립트 데이터 타입과 연산자
## 3.1 자바스크립트 기본 타입
- 기본타입과 참조타입
- 자바스크립트는 느슨한 타입 체크 언어( 변수 선언 시 var를 이용)

### 3.1.1 숫자
- 자바스크립트의 숫자는 64비트 부동 소수점인 number타입

### 3.1.2 문자열
- 작은 따옴표(‘)나 큰 따옴표(“)로 생성
- 한번 정의된 문자열은 불변
```JAVASCRIPT
var str = ‘test’;
console.log(str[0], str[1], str[2], str[3]);

str[0] = ’T’;
console.log(str) // test
```

### 3.1.3 불린값
- true, false

### 3.1.4 null과 undefined
- null : 변수를 선언하고 null 이라는 빈 값을 할당 한 상태(객체)
- undefined : 변수를 선언 후 값을 할당하지 않은 상태 즉, 자료형이 결정되지 않은 상태. undefiend는 타입이자, 값을 나타냄

## 3.2 자바스크립트 참조 타입
- 기본 타입을 제외한 모든 값은 객체(배열, 함수, 정규표현식 등)
- "이름:값” 형태의 프로퍼티들을 저장하는 컨테이너
- 프로퍼티에 함수가 지정되면 메서드라고 부름

### 3.2.1 객체 생성
- Object() 객체 생성자 함수 이용

```JAVASCRIPT
var foo = new Object();
foo.name = ‘foo’;
```

- 객체 리터럴

```JAVASCRIPT
var foo = {
     name : ‘foo'
};

```
- 생성자 함수 이용
```JAVASCRIPT
var add = new Function(‘x’, ‘y’, ‘return x+y’);
```

### 3.2.2 객체 프로퍼티 읽기/쓰기/갱신
- 객체 프로퍼티에 접근하기 위해 대괄호([]) 표기법과 마침표(.) 표기법 이용
- 대괄호 표기법에서는 접근하려는 프로퍼티를 문자열로 만들어야 함
- 기존 프로퍼티 갱신 및 동적 생성이 가능
- 프로퍼티가 표현식이거나 예약어일 경우 대괄호 표기법만 이용하여 접근

### 3.2.3 for in 문과 객체 프로퍼티 출력
```JAVASCRIPT
var foo = {
     name : ‘foo’,
     age : 34
};
var prop;
for(prop in foo) {
     console.log(prop, foo[prop]);
}
```

### 3.2.4 객체 프로퍼티 삭제
- delete 연산자를 이용하여 객체 프로퍼티 삭제

## 3.3 참조 타입의 특성
- 객체의 연산은 실제값이 아닌 참조값을 가지고 처리
```JAVASCRIPT
var objA = {
     val : 40
}
var objB = objA;

console.log(objA); //40
console.log(objB); //40

objB.val = 50;

console.log(objA); //50
console.log(objB); //50
```

### 3.3.1 객체 비교
- 객체의 비교도 실제값이 아닌 참조값을 비교한다.
```JAVASCRIPT
var a = 100;
var b = 100;

var objA = {
     value : 100
};
var objB = {
     value : 100
};
var objC = objB;

console.log(a == b);  // true
console.log(objA == obj B); // false
console.log(objB == objC); // true
```

### 3.3.2 참조에 의한 함수 호출 방식
- 기본 타입의 경우 Call by Value, 참조 타입(객체)의 경우 Call by Reference

## 3.4 프로토타입
- 모든 객체는 자신의 부모 역할을 하는 객체와 연결되어 있고, 이러한 부모 객체를 프로토타입 객체라고 함
- 프로토타입을 이용하여 부모 객체의 프로퍼티를 마치 자신의 것처럼 사용 가능(객체지향 상속 개념과 유사)

## 3.5 배열
- 크기 지정을 안해도 되며, 어떤 위치에 어느 타입의 데이터를 저장하여도 에러가 발생하지 않는다.

### 3.5.1 배열 리터럴
- 대괄호([]) 이용

### 3.5.2 배열의 요소 생성
- 아무 인덱스 위치에나 값을 동적으로 추가 가능
```JAVASCRIPT
var emptyArr = [];
console.log(emptyArr[0]);  // undefined

emptyArr[0] = 100;
emptyArr[3] = ‘eight’;
emptyArr[7] = true;
console.log(emptyArr)_; // [100, undefined x 2, “eight”, undefined x 3, true]
console.log(emptyArr.length); // 8
```

### 3.5.3 배열의 length 프로퍼티
- 자바스크립트의 모든 배열에는 length 프로퍼티가 존재
- 배열 내 가장 큰 인덱스값 + 1 (push 등 배열 메서드에서 length 프로퍼티를 기반으로 동작함)

### 3.5.4 배열과 객체
- 배열도 객체다
- 생성 방식의 차이
- length 프로퍼티 존재 여부
- Array.prototype / Object.prototype

### 3.5.5 배열의 프로퍼티 동적 생성
- 배열도 객체이므로 프로퍼티 생성 가능
- 배열에 프로퍼티를 추가해도 length 프로퍼티는 변경되지 않는다.

### 3.5.6 배열의 프로퍼티 열거
- for in문 / for 문
```JAVASCRIPT
for (var prop in arr) {
     console.log(prop, arr[prop]);
}
for (var i = 0 ; i < arr.length ; i++) {
     console.log(i, arr[i]);
}
```

### 3.5.7 배열 요소 삭제
- 배열도 객체이므로 delete 연산자 사용 가능, delete로 배열 요소 삭제 시 undefined가 할당되고 length 값은 변하지 않는다.(요소를 삭제하지는 않는다)
- splice() 배열 머서드를 사용하면 요소 자체를 삭제

### 3.5.8 Array() 생성자 함수
- new Array() 사용
- 인자가 1개이고 숫자인 경우 : 호출된 인자를 length로 갖는 빈 배열 생성
- 그 외의 경우 : 호출된 인자를 요소로 갖는 배열 생성

### 3.5.9 유사 배열 객체
- 객체에 length 프로퍼티 추가한 경우, 표준 배열 메서드를 사용하는게 가능해짐(call(), apply()메서드 이용)

## 3.6 기본 타입과 표준 메서드
- 기본 타입에 표준 메서드 호출 시 메서드 처리 순간에 객체로 변환된 다음 메서드 호출이 종료되면 기본값으로 복귀

## 3.7 연산자
### 3.7.1 + 연산자
- 더하기, 문자열 연결 연산자

### 3.7.2 typeof 연산자
- 피연산자의 타입을 문자열 형태로 리턴

### 3.7.3 ==(동등) 연산자와 ===(일치) 연산자
- 동등 연산자는 자료형을 맞춰서 비교, 일치 연산자는 자료형까지 맞아야 된다.

### 3.7.4 !! 연산자
- 피연산자를 불린값으로 변환
